[
  {
    "objectID": "posts/Visualization plotly/climate_database.html",
    "href": "posts/Visualization plotly/climate_database.html",
    "title": "Using Geographic, Boxplot, and Lineplot Visualizations to illustrate Global Warming",
    "section": "",
    "text": "import sqlite3\nimport pandas as pd\nimport numpy as np\nfrom matplotlib import pyplot as plt\nfrom sklearn.linear_model import LinearRegression\nfrom plotly import express as px\nimport plotly.io as pio\npio.renderers.default=\"iframe\"\n\n\n1. Database Creation\nFirst, create three separate tables: temperatures, countries, and stations table. To do so, I wrote a function named prepare_df to prepare the temperature dataset such that the data is easier to understand.\n\nThe temperatures table will contain station ID, year of measurement, month of measurement, and average temperature.\nThe countries table will contain country names and their corresponding country codes.\nThe stations table will contain station ID, latitude, longitude, elevation, and the name of the station.\n\n\ndef prepare_df(df):\n    df = df.set_index(keys=[\"ID\", \"Year\"])\n    df = df.stack()\n    df = df.reset_index()\n    df = df.rename(columns = {\"level_2\"  : \"Month\" , 0 : \"Temp\"})\n    df[\"Month\"] = df[\"Month\"].str[5:].astype(int)\n    df[\"Temp\"]  = df[\"Temp\"] / 100\n    df[\"NewID\"] = df[\"ID\"].str[0:2]\n    return(df)\n\n\nwith sqlite3.connect(\"HW1.db\") as conn: # create a database in current directory called temps.db\n    df_iter = pd.read_csv(\"temps.csv\", chunksize = 100000)\n    for i, df in enumerate(df_iter):\n        df = prepare_df(df)\n        df.to_sql(\"temperatures\", conn, if_exists = \"replace\" if i == 0 else \"append\", index = False)\n    url = \"station-metadata.csv\"\n    stations = pd.read_csv(url)\n    stations[\"NewID\"] = stations[\"ID\"].str[0:2]\n    stations.to_sql(\"stations\", conn, if_exists = \"replace\", index=False)\n    countries = pd.read_csv(\"countries.csv\")\n    countries = countries.rename(columns={\"FIPS 10-4\": \"NewID\"})\n    countries.to_sql(\"countries\", conn, if_exists = \"replace\", index=False)\n\nTemperatures dataframe\n\ndf.head() \n\n\n\n\n\n\n\n\nID\nYear\nMonth\nTemp\nNewID\n\n\n\n\n0\nUSW00014924\n2016\n1\n-13.69\nUS\n\n\n1\nUSW00014924\n2016\n2\n-8.40\nUS\n\n\n2\nUSW00014924\n2016\n3\n-0.20\nUS\n\n\n3\nUSW00014924\n2016\n4\n3.21\nUS\n\n\n4\nUSW00014924\n2016\n5\n13.85\nUS\n\n\n\n\n\n\n\nStations dataframe\n\nstations.head()\n\n\n\n\n\n\n\n\nID\nLATITUDE\nLONGITUDE\nSTNELEV\nNAME\nNewID\n\n\n\n\n0\nACW00011604\n57.7667\n11.8667\n18.0\nSAVE\nAC\n\n\n1\nAE000041196\n25.3330\n55.5170\n34.0\nSHARJAH_INTER_AIRP\nAE\n\n\n2\nAEM00041184\n25.6170\n55.9330\n31.0\nRAS_AL_KHAIMAH_INTE\nAE\n\n\n3\nAEM00041194\n25.2550\n55.3640\n10.4\nDUBAI_INTL\nAE\n\n\n4\nAEM00041216\n24.4300\n54.4700\n3.0\nABU_DHABI_BATEEN_AIR\nAE\n\n\n\n\n\n\n\nCountries dataframe\n\ncountries.head()\n\n\n\n\n\n\n\n\nNewID\nISO 3166\nName\n\n\n\n\n0\nAF\nAF\nAfghanistan\n\n\n1\nAX\n-\nAkrotiri\n\n\n2\nAL\nAL\nAlbania\n\n\n3\nAG\nDZ\nAlgeria\n\n\n4\nAQ\nAS\nAmerican Samoa\n\n\n\n\n\n\n\n\ndb_file = \"HW1.db\" #database we created \n\n\n\n2. Query Function\nBelow I created a query function query_climate_database which returns a dataframe based off of filters. The parameters specify the country, the year we start from, the year we end at, and the month we wish to analyze. The dataframe displays station name, latitude, longitude, and average temperature of the station during the month and year.\n\ndef query_climate_database(db_file, country, year_begin, year_end, month):\n    \"\"\"\n    Query function to filter climate data \n    \n    Args:\n    country: country of interest \n    year_begin: start year desired \n    year_end: end year desired \n    month: a specific month \n    \n    Return:\n    Dataframe of filtered data \n    \"\"\"\n    with sqlite3.connect(db_file) as conn:\n        cmd = \\\n        f\"\"\"\n        SELECT S.Name, S.LATITUDE, S.LONGITUDE, C.Name \"Country\", T.Year, T.Month, T.Temp\n        FROM stations S \n        LEFT JOIN countries C ON C.NewID = S.NewID\n        RIGHT JOIN temperatures T ON S.ID = T.ID \n        WHERE T.Year &lt;= {year_end} AND T.Year &gt;= {year_begin} AND T.Month = {month} AND C.Name = \"{country}\"\n        \"\"\" \n        df = pd.read_sql_query(cmd, conn)\n        return(df)\n\nBelow is an example with parameters country India, year_begin 1980, year_end 2020, and month 1\n\ndf = query_climate_database(db_file = \"HW1.db\", \n                            country = \"India\",\n                            year_begin = 1980, \n                            year_end = 2020, \n                            month = 1)\ndf\n\n\n\n\n\n\n\n\nNAME\nLATITUDE\nLONGITUDE\nCountry\nYear\nMonth\nTemp\n\n\n\n\n0\nPBO_ANANTAPUR\n14.583\n77.633\nIndia\n1980\n1\n23.48\n\n\n1\nPBO_ANANTAPUR\n14.583\n77.633\nIndia\n1981\n1\n24.57\n\n\n2\nPBO_ANANTAPUR\n14.583\n77.633\nIndia\n1982\n1\n24.19\n\n\n3\nPBO_ANANTAPUR\n14.583\n77.633\nIndia\n1983\n1\n23.51\n\n\n4\nPBO_ANANTAPUR\n14.583\n77.633\nIndia\n1984\n1\n24.81\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n3147\nDARJEELING\n27.050\n88.270\nIndia\n1983\n1\n5.10\n\n\n3148\nDARJEELING\n27.050\n88.270\nIndia\n1986\n1\n6.90\n\n\n3149\nDARJEELING\n27.050\n88.270\nIndia\n1994\n1\n8.10\n\n\n3150\nDARJEELING\n27.050\n88.270\nIndia\n1995\n1\n5.60\n\n\n3151\nDARJEELING\n27.050\n88.270\nIndia\n1997\n1\n5.70\n\n\n\n\n3152 rows × 7 columns\n\n\n\n\n\n3. Geographic Mapbox Scatterplot\nWe use query_climate_database to create another function temperature_coefficient plot which answers how the average yearly change in temperature varies within a country. The function accepts the same parameters, as well as min_obs which will filters stations which do not have the specified number of data points. We also add **kwargs to customize our mapbox scatterplot we made using px.scatter_mapbox().\nInside our function, I wrote another function coef which conducts linear regression in order to compute how each station changes in average temperature over time.\n\ndef temperature_coefficient_plot(db_file, country, year_begin, year_end, month, min_obs, **kwargs):\n    \"\"\"\n    Construct a geographic mapbox scatterplot of yearly temperature increase\n    \n    Args:\n    country: desired country to display \n    year_begin: desired start year \n    year_end: desired end year \n    month: a specific month \n    min_obs: minimum required observations of station\n    **kwargs: additional keyword arguments\n    \n    Return:\n    Scatter_mapbox plot\n    \"\"\"\n    import calendar \n    def coef(data_group):\n        x = data_group[[\"Year\"]] # 2 brackets because X should be a df\n        y = data_group[\"Temp\"]   # 1 bracket because y should be a series\n        LR = LinearRegression()\n        LR.fit(x, y)\n        return LR.coef_[0]\n    df = query_climate_database(db_file, country, year_begin, year_end, month)\n    test = df.groupby([\"NAME\"]).size()\n    names = test[test &gt;= min_obs].index\n    df = df[df.NAME.isin(names)]\n    coefs = df.groupby([\"NAME\", \"Month\"]).apply(coef).round(4)\n    plot_df = pd.DataFrame(coefs)\n    merged_df = pd.merge(df, plot_df, on='NAME')\n    merged_df = merged_df.rename(columns={0: \"Estimated Yearly Increase (Celcius)\"})\n    fig = px.scatter_mapbox(merged_df, \n                            lat = \"LATITUDE\",\n                            lon = \"LONGITUDE\", \n                            hover_name=\"NAME\", \n                            color_continuous_midpoint = 0,\n                            color = \"Estimated Yearly Increase (Celcius)\",\n                            title = (f\"\"\"Estimates of yearly increase in {calendar.month_name[month]} \n                             &lt;br&gt;temperature for stations in {country}, from {year_begin} to {year_end}\"\"\"),\n                            **kwargs)\n    return(fig)\n\nBelow we create a sample plot with the same parameters we used in the query function along with new **kwargs parameters for the scatter_mapbox.\n\ncolor_map = px.colors.diverging.RdGy_r\nfig = temperature_coefficient_plot(db_file, \"India\", 1980, 2020, 1, 10,\n                                   zoom = 2,\n                                   mapbox_style=\"carto-positron\",\n                                   color_continuous_scale = color_map)\nfig.show()\n\n\n\n\nNow let us try this with a new example. Here I used the parameters country = Portugal, year_begin = 1980, year_end = 2020, and month = 2.\n\nfig = temperature_coefficient_plot(db_file, \"Portugal\", 1980, 2020, 2, \n                                   min_obs = 10,\n                                   zoom = 2,\n                                   mapbox_style=\"carto-positron\",\n                                   color_continuous_scale=color_map)\n\nfig.show()\n\n\n\n\n\n\n4. Additional Query Function and Plotly Boxplot and Lineplot\nI decided to write a query function which filters out only the equator countries. The reason why I did this was because I believe that it is valuable to see how the temperature changes each year from these equator countries because it may illustrate that even at the hottest parts of our world, the temperature increases, potentially infering global warming.\n\ndef query_equator(db_file, year_begin, year_end):\n    \"\"\"\n    Query function of only the Equator countries\n    \n    Args:\n    country: desired country to display \n    year_begin: desired start year \n    year_end: desired end year\n    \n    Return:\n    Dataframe with desired filters \n    \"\"\"\n    with sqlite3.connect(db_file) as conn:\n        cmd = \\\n        f\"\"\"\n        SELECT S.Name, S.LATITUDE, S.LONGITUDE, C.Name \"Country\", T.Year, T.Month, T.Temp\n        FROM stations S \n        LEFT JOIN countries C ON C.NewID = S.NewID\n        RIGHT JOIN temperatures T ON S.ID = T.ID \n        WHERE T.Year &lt;= {year_end} AND T.Year &gt;= {year_begin} AND S.LATITUDE &gt;= -5 AND S.LATITUDE &lt;= 5\n        AND (C.Name = \"Congo, Democratic Republic of the\" OR C.Name = \"Gabon\" \n        OR C.Name = \"Somalia\" \n        OR C.Name = \"Congo, Republic of the\" OR C.Name = \"Uganda\" \n        OR C.Name = \"Maldives\" OR C.Name = \"Indonesia\" OR C.Name = \"Kiribati\" \n        OR C.Name = \"Sao Tome and Principe\" OR C.Name = \"Kenya\" \n        OR C.Name = \"Ecuador\" OR C.Name = \"Colombia\" OR C.Name = \"Brazil\")\n        \"\"\" \n        df = pd.read_sql_query(cmd, conn)\n        return(df)\n\nHere I created a dataframe of just equator countries from 2010 - 2020.\n\ndf = query_equator(db_file, 2010, 2020)\ndf\n\n\n\n\n\n\n\n\nNAME\nLATITUDE\nLONGITUDE\nCountry\nYear\nMonth\nTemp\n\n\n\n\n0\nPORTO_DE_MOZ\n-1.733\n-52.233\nBrazil\n2010\n1\n27.69\n\n\n1\nPORTO_DE_MOZ\n-1.733\n-52.233\nBrazil\n2010\n2\n28.11\n\n\n2\nPORTO_DE_MOZ\n-1.733\n-52.233\nBrazil\n2010\n3\n28.85\n\n\n3\nPORTO_DE_MOZ\n-1.733\n-52.233\nBrazil\n2010\n4\n27.79\n\n\n4\nPORTO_DE_MOZ\n-1.733\n-52.233\nBrazil\n2010\n5\n28.27\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n16227\nMASINDI\n1.683\n31.717\nUganda\n2011\n8\n21.98\n\n\n16228\nMASINDI\n1.683\n31.717\nUganda\n2011\n9\n22.09\n\n\n16229\nMASINDI\n1.683\n31.717\nUganda\n2011\n10\n23.01\n\n\n16230\nMASINDI\n1.683\n31.717\nUganda\n2011\n11\n23.29\n\n\n16231\nMASINDI\n1.683\n31.717\nUganda\n2011\n12\n24.50\n\n\n\n\n16232 rows × 7 columns\n\n\n\nThe temperature_box_plot function below addresses how the average temperature of countries on the equator change year to year. I made sure that the function uses the same station for every year such that the data is not unevenly weighted. The plot which this function produces is important because we can see if our temperature is rising or lowering as time goes on. And as we can see from the figure below, there is a slight gradual increase in the boxplot medians of Brazil, providing visual evidence that temperatures are increasing for equator countries.\n\ndef temperature_box_plot(db_file, country, year_begin, year_end, **kwargs):\n    \"\"\"\n    Construct boxplot of yearly average temperatures of specified equator country \n    \n    Args:\n    country: desired country to display \n    year_begin: desired start year \n    year_end: desired end year \n    \n    Return:\n    px.box plot of yearly average temperatures of specified equator country\n    \"\"\"\n    df = query_equator(db_file, year_begin, year_end)\n    df = df[df.Country == country]\n    new = df.groupby([\"NAME\", \"Year\"])[\"Temp\"].aggregate(np.mean)\n    test = df.groupby([\"NAME\", \"Year\"]).size()\n    test = test.reset_index()\n    names = test.groupby([\"NAME\"]).size() &gt;= year_end - year_begin + 1 \n    names = names[names].index\n    plot_df = pd.DataFrame(new)\n    plot_df = plot_df.reset_index()\n    plot_df = plot_df[plot_df.NAME.isin(names)]\n    fig = px.box(df,\n                 x = \"Country\",\n                 y = \"Temp\",\n                 color = \"Year\",\n                 title = f\"Boxplots of {country}'s Average Temperature by Year from {year_begin} to {year_end}\",\n                 category_orders={\"Year\": [ix for ix in range(year_begin, year_end)]},\n                 **kwargs\n                )\n    return fig\n\n\nfig = temperature_box_plot(db_file, \"Brazil\", 1980, 2020)\nfig.show()\n\n\n\n\nI constructed the temperature_lineplot_equator function to display a lineplot of how the temperature changes over time in each month, and each colored line on the lineplot represents a different station. I felt this was important because like the boxplot it was another way to visualize how there is an increase in temperature in equator countries. For instance, as we can see below the Average Temperature of Station in Indonesia from 1985 to 2020 increased for all 4 stations plotted.\n\ndef temperature_lineplot_equator(db_file, year_begin, year_end, country, month, **kwargs):\n    \"\"\"\n    Construct lineplot of yearly average temperatures of specified equator country in month\n    \n    Args:\n    country: desired country to display \n    year_begin: desired start year \n    year_end: desired end year \n    month: specific month of year\n    **kwargs: keyword arguments for lineplot\n    \n    Return:\n    px.line plot of yearly average temperatures of specified equator country\n    \"\"\"\n    import calendar \n    df = query_equator(db_file, year_begin, year_end)\n    df = df[df.Month == month]\n    df[\"Date\"] = pd.to_datetime(df[\"Year\"].astype(str) + \"-\" + df[\"Month\"].astype(str))\n    df = df[df.Country == country]\n    new = df.groupby([\"NAME\", \"Date\"])[\"Temp\"].aggregate(np.mean)\n    test = df.groupby([\"NAME\", \"Date\"]).size()\n    test = test.reset_index()\n    names = test.groupby([\"NAME\"]).size() &gt;= (year_end - year_begin) - 5  \n    names = names[names].index\n    plot_df = pd.DataFrame(new)\n    plot_df = plot_df.reset_index()\n    plot_df = plot_df[plot_df.NAME.isin(names)]\n    fig = px.line(data_frame = plot_df,\n                  x = \"Date\",\n                  y = \"Temp\",\n                  color = \"NAME\",\n                  title = (f\"\"\"Average Temperature of Station in {country} &lt;br&gt;\n                           by Year in {calendar.month_name[month]} from {year_begin} to {year_end}\"\"\"),\n                  )\n    return(fig)\n\n\nplot = temperature_lineplot_equator(db_file, 1985, 2020, \"Indonesia\", 6)\nplot.show()\n\n\n\n\n\n\n5. Concluding Remarks\nAs we can see from the query functions and graphics constructed, there is overwhelming evidence for global warming. The mapbox plot, boxplot, and line plots all show that there is a majority increase in temperature, and this conclusion was able to be realized because the visualizations helped to easily explain the data."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Blog",
    "section": "",
    "text": "Using Geographic, Boxplot, and Lineplot Visualizations to illustrate Global Warming\n\n\n\n\n\n\nSQLITE\n\n\nVisualization\n\n\n\n\n\n\n\n\n\nJan 23, 2024\n\n\nTyler Nguyen\n\n\n\n\n\n\n\n\n\n\n\n\nBlog Tutorial HW0\n\n\n\n\n\n\nweek 0\n\n\nhomework\n\n\n\n\n\n\n\n\n\nJan 22, 2024\n\n\nTyler Nguyen\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/bruins/HW0- Blog Tutorial.html",
    "href": "posts/bruins/HW0- Blog Tutorial.html",
    "title": "Blog Tutorial HW0",
    "section": "",
    "text": "First read in the data\n\nimport pandas as pd\nurl = \"https://raw.githubusercontent.com/pic16b-ucla/24W/main/datasets/palmer_penguins.csv\"\npenguins = pd.read_csv(url)\n\n\n\nNow let’s look at the first few rows of the dataset.\n\npenguins.head()\n\nIt appears that there are a few numeric columns in our dataframe which would be easy to analyze. Let’s specifically look at two and plot them on a scatter plot.\n\n\nLet’s import the seaborn package and create a scatterplot\nFor this example, I chose ‘Culmen Length’ and ’Flipper Length). I imported the seaborn package as it has great functions for visualization. I chose to create a scatterplot because it is the best way to analyze numeric data against numeric data.\n\nimport seaborn as sns\n\nsns.scatterplot(\n    data = penguins,\n    x = \"Culmen Length (mm)\", \n    y = \"Flipper Length (mm)\")\n\n\n\n\n\n\n\n\nIt appears that there is a positive relationship between culmen length and flipper length.\n\n\nNow go one step further!\nLet’s go even further through analyzing if the type of species affects this relationship. To do this, we add the hue parameter. I also used the set_title function to make our plot look even better!\n\nsns.scatterplot(\n    data = penguins,\n    x = \"Culmen Length (mm)\", \n    y = \"Flipper Length (mm)\", \n    hue = \"Species\").set_title(\"Flipper Length vs Culmen Length in mm vs Species\")\n\nText(0.5, 1.0, 'Flipper Length vs Culmen Length in mm vs Species')\n\n\n\n\n\n\n\n\n\nAs we can see, species type does seem to affect the culmen length and flipper length values. For instance, there appears to be distinct groupings based upon species type, as the Gentoo Penguin appears to have the longest dimensions with the adelie penguins and chinstrap penguins having similar flipper lengths but differing culmen lengths.\n\n\nWe’re done!"
  }
]